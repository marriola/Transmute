// Project:     TransmuteLib
// Module:      Transducer
// Description: Transforms a word using a finite state transducer generated by the RuleCompiler and DeterministicFiniteAutomaton modules.
// Copyright:   (c) 2023 Matt Arriola
// License:     MIT

namespace TransmuteLib

open TransmuteLib.StateMachine
open TransmuteLib.Utils.Operators

module Transducer =
    /// Returns the original value if input is the special begin or end symbol.
    /// Otherwise, returns the result of fTransform.
    let private addChar constructor symbol xs  =
        if symbol = Special.START || symbol = Special.END then
            xs
        else
            constructor (string symbol) :: xs

    /// An input symbol tagged with the action taken when processing it
    type internal BufferString =
        | Unchanged of position: int * symbol: string
        | Replaced of position: int * symbol: string * original: string
        | Inserted of position: int * symbol: string
        | Deleted of position: int * count: int * symbol: string
        with
            /// Returns true if the string is a replacement, insertion or deletion; otherwise, false.
            static member isMutation = function
                | Replaced _ | Inserted _ | Deleted _ -> true
                | _ -> false

            /// Gets the symbol.
            static member getText = function
                | Unchanged (_, s)
                | Replaced (_, s, _)
                | Inserted (_, s)
                | Deleted (_, _, s) -> s

            /// Gets the original untransformed symbol.
            static member getOriginal = function
                | Unchanged (_, s)
                | Inserted (_, s)
                | Deleted (_, _, s) ->
                    s
                | Replaced (_, _, original) ->
                    original

            /// Gets the difference in length between the result of the change and the original symbol
            static member getLengthDifference = function
                | Unchanged _ -> 0
                | Inserted (_, s) -> s.Length
                | Deleted (_, _, s) -> -(s.Length)
                | Replaced (_, replacement, original) -> replacement.Length - original.Length

            /// Replaces the original symbol.
            static member withText (text: string) = function
                | Unchanged (p, _) -> Unchanged (p, text)
                | Replaced (p, s, _) -> Replaced (p, s, text)
                | Inserted (p, _) -> Inserted (p, text)
                | Deleted (p, _, _) -> Deleted (p, text.Length, text)

            /// Replaces the symbol position.
            static member withPosition p = function
                | Unchanged (_, s) -> Unchanged (p, s)
                | Replaced (_, s, r) -> Replaced (p, s, r)
                | Inserted (_, s) -> Inserted (p, s)
                | Deleted (_, c, s) -> Deleted (p, c, s)

            /// Gets the symbol position.
            static member getPosition = function
                | Unchanged (p, _)
                | Replaced (p, _, _)
                | Inserted (p, _)
                | Deleted (p, _, _) ->
                    p

            /// Adds a production to the production buffer.
            static member addProduction position value symbol production =
                match production with
                | ReplacesWith (count, s) ->
                    // If this is a non-initial part of a multi-character match, drop the last replacement
                    let bufferLength = List.length value.buffer
                    let skip = min bufferLength count
                    let nextProduction = Replaced (position, s, string symbol) :: value.buffer
                    BufferString.coalesce (skip + 1) nextProduction

                | Inserts s ->
                    let buffer =
                        match value.buffer with
                        | Inserted _ :: rest ->
                            // Drop insertion from an incomplete application
                            rest
                        | Unchanged (_, "_") as underscore :: Inserted _ :: rest ->
                            // Same as above, but preserve intervening X-SAMPA underscore
                            underscore :: rest
                        | _ ->
                            value.buffer

                    Inserted (position + 1, s) :: Unchanged (position, string symbol) :: buffer

                | Deletes (count, _) ->
                    let prefix, position, buffer =
                        match value.buffer with
                        | Deleted (firstPosition, _, s) :: rest ->
                            s, firstPosition, rest
                        | _ ->
                            "", position, value.buffer

                    Deleted (position, count, prefix + string symbol) :: buffer

            /// Returns a list of raw strings with replacements and insertions reversed.
            static member undo xs =
                xs
                |> List.choose (function
                    | Unchanged (_, s)
                    | Replaced (_, _, s)
                    | Deleted (_, _, s) ->
                        Some s
                    | _ ->
                        None)

            /// Returns a list of raw strings with replacements and insertions.
            static member apply xs =
                xs
                |> List.choose (function
                    | Unchanged (_, s)
                    | Replaced (_, s, _)
                    | Inserted (_, s) ->
                        Some s
                    | _ ->
                        None)

            /// Drops the last N symbols from the buffer and adds a combined symbol
            static member coalesce n xs =
                let n = min n (List.length xs)
                if n < 2 then
                    xs
                else
                    // Take the position of the last string to coalesce, and combine the text of the first N strings
                    let ys = List.take n xs
                    let lastPosition =
                        ys
                        |> List.last
                        |> BufferString.getPosition
                    let ysText =
                        ys
                        |> List.map BufferString.getOriginal
                        |> List.rev
                        |> String.concat ""
                    // Add the updated head and skip the strings we just processed
                    let offset =
                        let headText = BufferString.getText xs[0]
                        if ysText.StartsWith headText then headText.Length else 0
                    let head =
                        xs[0]
                        |> BufferString.withText ysText
                        |> BufferString.withPosition (lastPosition + offset)
                    head :: List.skip n xs

            static member getChangeLocations offset xs =
                // Get a list of change locations and the difference in the length of the string caused by each change,
                // then compute a running total of the differences and add them to the position of each change as we go
                // through the list.
                let totalDifference, changes =
                    xs
                    |> List.filter BufferString.isMutation
                    |> List.map (fun bs -> BufferString.getPosition bs, BufferString.getLengthDifference bs)
                    |> List.rev
                    |> List.fold (fun (totalDifference, acc) (position, difference) ->
                        let acc = (position + offset + totalDifference) :: acc
                        let totalDifference = totalDifference + difference
                        totalDifference, acc) (0, [])

                offset + totalDifference, changes

    and internal TransducerState = {
        /// Indicates whether the rule has begun to match to the input.
        isPartialMatch: bool

        /// Indicates whether the last state visited was a final state.
        wasLastFinal: bool

        /// Locations where the rule applied to the word.
        locations: int list

        /// The total difference in the length of the string accumulated from the committed changes so far.
        /// This is used to keep change locations accurate as characters get inserted and removed.
        locationOffset: int

        /// The current production.
        buffer: BufferString list

        /// The output buffer.
        output: string list
    }
    
    /// <summary>
    /// Applies a compiled rule to a word.
    /// </summary>
    /// <param name="verbose">If true, displays the state of the state machine at each step.</param>
    /// <param name="rule">The rule to apply.</param>
    /// <param name="word">The word to transform.</param>
    let private transformInternal reportChangeLocations verbose syllableBoundaryLocations rule word =
        // Debug output columns
        //  is valid transition
        //  position in word
        //  transition
        //  --------------------
        //  output buffer
        //  production buffer

        let transitions, transformations = rule
        //let word =
        //    syllableBoundaryLocations
        //    |> List.fold (fun (s: string) i -> s[..i - 1] + (string Special.SYLLABLE_SEPARATOR) + s[i..]) word

        if verbose then
            printfn "%s" (new System.String('-', 80))

        stateMachineConfig()
        |> withTransitions transitions
        |> withStartState RuleCompiler.START
        |> withErrorState RuleCompiler.ERROR
        |> withInitialValue
            { isPartialMatch = false
              wasLastFinal = false
              locationOffset = 0
              locations = []
              output = []
              buffer = [] }
        |> onError (fun input machineState ->
            let { position = position; currentValue = value; currentState = current } = machineState
            let position = position - 1

            let nextOutput =
                if value.isPartialMatch then
                    if value.wasLastFinal then
                        // The rule failed to match completely, but what did match was enough to commit the production (i.e. any remaining nodes were optional).
                        BufferString.apply value.buffer @ value.output
                    else
                        // The rule failed to match
                        BufferString.undo value.buffer @ value.output
                else
                    // The rule has not yet begun to match.
                    if input <> Special.START && input <> Special.END && input <> Special.SYLLABLE_SEPARATOR then
                        string input :: value.output
                    else
                        value.output

            let nextOffset, nextLocations =
                if reportChangeLocations && value.isPartialMatch && value.wasLastFinal then
                    let nextOffset, changes = BufferString.getChangeLocations value.locationOffset value.buffer
                    nextOffset, value.locations @ changes
                else
                    value.locationOffset, value.locations

            if verbose then
                let nextOutputStr = nextOutput |> List.rev |> List.map string |> String.concat ""
                printf $"   %2d{position} %c{input}: "
                printfn $"Error at %-25O{current} | %-20s{nextOutputStr}"

            Restart {
                value with
                    isPartialMatch = false
                    locations = nextLocations
                    locationOffset = nextOffset
                    buffer = []
                    output = nextOutput
            })
        |> onTransition (fun symbol t machineState ->
            let (_, _, To nextState) = t
            let { position = position; currentState = current; currentValue = value } = machineState
            let { buffer = production; output = output } = value
            let position = position - 1
            let isNextFinal = State.isFinal nextState
            let tf = Map.tryFind t transformations

            if verbose then
                printf $" • %2d{position} %c{symbol}: "

            let nextProduction =
                match tf with
                | None ->
                    addChar (tuple2 position >> Unchanged) symbol production
                | Some tf ->
                    BufferString.addProduction position value symbol tf

            if verbose then
                let transition = $"{current} -> {nextState}"
                let nextOutputStr = output |> List.rev |> List.map string |> String.concat ""
                let nextProductionStr = nextProduction |> List.rev |> List.map string |> String.concat " "
                printfn $"%-34s{transition} | %-20s{nextOutputStr} {nextProductionStr}"

            { value with
                isPartialMatch = true
                wasLastFinal = isNextFinal
                buffer = nextProduction })
        |> onFinish (fun value ->
            // Flush last production
            let outputBuffer, locations =
                if value.wasLastFinal then
                    let out = BufferString.apply value.buffer @ value.output
                    let _, changes = BufferString.getChangeLocations value.locationOffset value.buffer
                    let locations = value.locations @ changes
                    out, locations
                else
                    value.output, value.locations
            let output = outputBuffer |> List.rev |> String.concat ""
            output, locations)
        |> runDFA (string Special.START + word + string Special.END)

    /// Applies a rule to a word.
    let transform verbose syllableBoundaryLocations rule word =
        let result, _ = transformInternal false verbose syllableBoundaryLocations rule word
        result

    /// Applies a rule to a word, returning locations where the rule applied along with the new word.
    let transformWithChangeLocations verbose syllableBoundaryLocations rule word =
        transformInternal true verbose syllableBoundaryLocations rule word

    let getIpaChangeLine ruleNum (changes: int list) (result: string) =
        let result = result |> List.ofSeq
    
        // Insert a combining long underline after each change, but if there's a deletion at the end, put a regular underscore there
        let deletionAtEnd, changes =
            changes
            |> List.rev
            |> List.partition ((<=) result.Length)
        let outChars =
            let chars =
                (result, changes)
                ||> List.fold (fun result location -> List.insertAt (location + 1) '\u0332' result)
            if List.isEmpty deletionAtEnd then
                chars
            else
                chars @ ['_']

        let out = System.String.Join("", outChars)

        [ $"%2d{ruleNum}. {out}" ]

    let getXsampaChangeLine ruleNum (changes: int list) (result: string) = 
        let maxIndex = List.max changes + 1

        let changeLine =
            Array.create maxIndex ' '
            |> Array.mapi (fun i _ -> if List.contains i changes then '^' else ' ')

        [
            $"%2d{ruleNum}. {result}"
            "    " + System.String.Join("", changeLine)
        ]
