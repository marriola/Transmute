// Project:     TransmuteLib
// Module:      Transducer
// Description: Transforms a word using a finite state transducer generated by the RuleCompiler and DeterministicFiniteAutomaton modules.
// Copyright:   (c) 2023 Matt Arriola
// License:     MIT

namespace TransmuteLib

open TransmuteLib.StateMachine
open TransmuteLib.Utils.Operators

module Transducer =
    /// Returns the original value if input is the special begin or end symbol.
    /// Otherwise, returns the result of fTransform.
    let private addChar constructor symbol xs  =
        if symbol = Special.START || symbol = Special.END then
            xs
        else
            constructor (string symbol) :: xs

    /// An input symbol tagged with the action taken when processing it
    type internal BufferString =
        | Unchanged of position: int * symbol: string
        | Replaced of position: int * symbol: string * original: string
        | Inserted of position: int * symbol: string
        | Deleted of position: int * count: int * symbol: string
        with
            /// Returns true if the string is a replacement, insertion or deletion; otherwise, false.
            static member isMutation = function
                | Replaced _ | Inserted _ | Deleted _ -> true
                | _ -> false

            /// Gets the symbol.
            static member getText = function
                | Unchanged (_, s)
                | Replaced (_, s, _)
                | Inserted (_, s)
                | Deleted (_, _, s) -> s

            /// Gets the original untransformed symbol.
            static member getOriginal = function
                | Unchanged (_, s)
                | Inserted (_, s)
                | Deleted (_, _, s) ->
                    s
                | Replaced (_, _, original) ->
                    original

            /// Replaces the original symbol.
            static member withText (text: string) = function
                | Unchanged (p, _) -> Unchanged (p, text)
                | Replaced (p, s, _) -> Replaced (p, s, text)
                | Inserted (p, _) -> Inserted (p, text)
                | Deleted (p, _, _) -> Deleted (p, text.Length, text)

            /// Replaces the symbol position.
            static member withPosition p = function
                | Unchanged (_, s) -> Unchanged (p, s)
                | Replaced (_, s, r) -> Replaced (p, s, r)
                | Inserted (_, s) -> Inserted (p, s)
                | Deleted (_, c, s) -> Deleted (p, c, s)

            /// Gets the symbol position.
            static member getPosition = function
                | Unchanged (p, _)
                | Replaced (p, _, _)
                | Inserted (p, _)
                | Deleted (p, _, _) ->
                    p

            /// Adds a production to the production buffer.
            static member addProduction position value symbol production =
                match production with
                | ReplacesWith (count, s) ->
                    let bufferLength = List.length value.production
                    let skip = min bufferLength count
                    let nextProduction = Replaced (position, s, string symbol) :: value.production
                    BufferString.coalesce (skip + 1) nextProduction

                | Inserts (s) ->
                    let production =
                        match value.production with
                        | Inserted _ :: rest ->
                            // Drop insertion from an incomplete application
                            rest
                        | Unchanged (_, "_") as underscore :: Inserted _ :: rest ->
                            // Same as above, but preserve intervening X-SAMPA underscore
                            underscore :: rest
                        | _ ->
                            value.production

                    Inserted (position + 1, s) :: Unchanged (position, string symbol) :: production

                | Deletes (count, s) ->
                    let prefix, position, production =
                        match value.production with
                        | Deleted (firstPosition, _, s) :: rest ->
                            s, firstPosition, rest
                        | _ ->
                            "", position, value.production

                    Deleted (position, count, prefix + string symbol) :: production

            /// Returns a list of raw strings with replacements and insertions reversed.
            static member undo xs =
                xs
                |> List.choose (function
                    | Unchanged (_, s)
                    | Replaced (_, _, s)
                    | Deleted (_, _, s) ->
                        Some s
                    | _ ->
                        None)

            /// Returns a list of raw strings with replacements and insertions.
            static member apply xs =
                xs
                |> List.choose (function
                    | Unchanged (_, s)
                    | Replaced (_, s, _)
                    | Inserted (_, s) ->
                        Some s
                    | _ ->
                        None)

            /// Drops the last N symbols from the buffer and adds a combined symbol
            static member coalesce n xs =
                let n = min n (List.length xs)
                if n < 2 then
                    xs
                else
                    // Take the position of the last string to coalesce, and combine the text of the first N strings
                    let ys = List.take n xs
                    let lastPosition =
                        ys
                        |> List.last
                        |> BufferString.getPosition
                    let ysText =
                        ys
                        |> List.map BufferString.getOriginal
                        |> List.rev
                        |> String.concat ""
                    // Add the updated head and skip the strings we just processed
                    let head =
                        xs
                        |> List.head
                        |> BufferString.withText ysText
                        |> BufferString.withPosition lastPosition
                    head :: List.skip n xs

            static member getChangeLocations xs =
                xs
                |> List.filter BufferString.isMutation
                |> List.map BufferString.getPosition

    and internal RuleMachineState = {
        /// Indicates whether the rule has begun to match to the input.
        isPartialMatch: bool

        /// Indicates whether the last state visited was a final state.
        wasLastFinal: bool

        /// Locations where the rule applied to the word.
        locations: int list

        /// The current production.
        production: BufferString list

        /// The output buffer.
        output: string list
    }
    
    /// <summary>
    /// Applies a compiled rule to a word.
    /// </summary>
    /// <param name="verbose">If true, displays the state of the state machine at each step.</param>
    /// <param name="rule">The rule to apply.</param>
    /// <param name="word">The word to transform.</param>
    let private transformInternal reportChangeLocations verbose rule word =
        // Debug output columns
        //  is valid transition
        //  position in word
        //  transition
        //  --------------------
        //  output buffer
        //  production buffer

        let transitions, transformations = rule

        stateMachineConfig()
        |> withTransitions transitions
        |> withStartState RuleCompiler.START
        |> withErrorState RuleCompiler.ERROR
        |> withInitialValue
            { isPartialMatch = false
              wasLastFinal = false
              locations = []
              output = []
              production = [] }
        |> onError (fun position input current value _ ->
            let position = position - 1

            let nextOutput =
                if value.isPartialMatch then
                    if value.wasLastFinal then
                        // The rule failed to match completely, but what did match was enough to commit the production (i.e. any remaining nodes were optional).
                        BufferString.apply value.production @ value.output
                    else
                        // The rule failed to match
                        BufferString.undo value.production @ value.output
                // The rule has not yet begun to match.
                elif input <> Special.START && input <> Special.END then
                    string input :: value.output
                else
                    value.output

            let nextLocations =
                if reportChangeLocations && value.isPartialMatch && value.wasLastFinal then
                    value.locations @ BufferString.getChangeLocations value.production
                else
                    value.locations

            if verbose then
                let nextOutputStr = nextOutput |> List.rev |> List.map string |> String.concat ""
                printf $"   %2d{position} %c{input}: "
                printfn $"Error at %-25O{current} | %-20s{nextOutputStr}"

            Restart {
                value with
                    isPartialMatch = false
                    locations = nextLocations
                    production = []
                    output = nextOutput
            })
        |> onTransition (fun position transition _ symbol current nextState value ->
            let { production = production; output = output } = value
            let position = position - 1
            if verbose then
                printf $" • %2d{position} %c{symbol}: "
            let isNextFinal = State.isFinal nextState
            let tf = Map.tryFind transition transformations

            let nextProduction =
                match tf with
                | None ->
                    addChar (tuple2 position >> Unchanged) symbol production
                | Some tf ->
                    BufferString.addProduction position value symbol tf

            if verbose then
                let transition = $"{current} -> {nextState}"
                let nextOutputStr = output |> List.rev |> List.map string |> String.concat ""
                let nextProductionStr = nextProduction |> List.rev |> List.map string |> String.concat " "
                printfn $"%-34s{transition} | %-20s{nextOutputStr} {nextProductionStr}"
            { value with
                isPartialMatch = true
                wasLastFinal = isNextFinal
                production = nextProduction })
        |> onFinish (fun value ->
            // Flush last production
            let outputBuffer, locations =
                if value.wasLastFinal then
                    let out = BufferString.apply value.production @ value.output
                    let locations = value.locations @ BufferString.getChangeLocations value.production
                    out, locations
                else
                    value.output, value.locations
            let output = outputBuffer |> List.rev |> String.concat ""
            output, locations)
        |> runStateMachine (string Special.START + word + string Special.END)

    let transformWithChangeLocations verbose rule word =
        transformInternal true verbose rule word

    let transform verbose rule word =
        let result, _ = transformInternal false verbose rule word
        result
